<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournoi de Pong IA Évolutif</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            font-size: 2.8rem;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .game-section {
            flex: 1;
            background: rgba(10, 15, 35, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ff7e5f;
            display: flex;
            align-items: center;
        }
        
        .section-title svg {
            margin-right: 10px;
        }
        
        .tournament-section {
            flex: 1;
            min-width: 300px;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #0a1029;
            border-radius: 10px;
            overflow: hidden;
            border: 3px solid #2a3a7a;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }
        
        canvas {
            display: block;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .speed-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(20, 30, 60, 0.6);
            padding: 10px 15px;
            border-radius: 25px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .speed-controls label {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .speed-slider {
            width: 120px;
            height: 5px;
            border-radius: 5px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff7e5f;
            cursor: pointer;
        }
        
        .speed-display {
            font-weight: bold;
            color: #ff7e5f;
            min-width: 30px;
        }
        
        .match-status {
            background: rgba(20, 30, 60, 0.6);
            padding: 10px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
        }
        
        .match-status.blocked {
            background: rgba(200, 50, 50, 0.6);
            border: 1px solid #ff5252;
        }
        
        .anti-block-info {
            background: rgba(30, 30, 30, 0.8);
            padding: 8px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.8rem;
            opacity: 0.8;
        }
        
        button {
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(20, 30, 60, 0.6);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #ff7e5f;
            margin: 10px 0;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .bracket-container {
            background: rgba(10, 15, 35, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
        }
        
        .bracket {
            display: flex;
            min-width: 800px;
            justify-content: space-around;
        }
        
        .round {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            min-height: 500px;
        }
        
        .match {
            background: rgba(30, 40, 80, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            width: 200px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .match.active {
            background: rgba(70, 30, 80, 0.8);
            border: 1px solid #ff7e5f;
            transform: scale(1.05);
        }
        
        .match.winner {
            background: rgba(40, 100, 40, 0.8);
        }
        
        .match.blocked {
            background: rgba(100, 40, 40, 0.8);
            border: 1px solid #ff5252;
        }
        
        .player {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: rgba(50, 60, 100, 0.5);
        }
        
        .player.winner {
            background: rgba(60, 150, 60, 0.7);
            font-weight: bold;
        }
        
        .player span {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .aggressive span { background: #ff5252; }
        .defensive span { background: #4fc3f7; }
        .unpredictable span { background: #ba68c8; }
        
        .analytics {
            background: rgba(10, 15, 35, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 30px;
        }
        
        .styles-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .style-card {
            flex: 1;
            min-width: 250px;
            background: rgba(20, 30, 60, 0.6);
            border-radius: 10px;
            padding: 20px;
            border-top: 4px solid;
        }
        
        .aggressive-style { border-color: #ff5252; }
        .defensive-style { border-color: #4fc3f7; }
        .unpredictable-style { border-color: #ba68c8; }
        
        .style-card h3 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        
        .style-card h3 svg {
            margin-right: 10px;
        }
        
        .style-card ul {
            list-style-type: none;
            padding-left: 5px;
        }
        
        .style-card li {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .win-rate {
            font-size: 2rem;
            text-align: center;
            font-weight: bold;
            margin: 15px 0;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Tournoi de Pong IA Évolutif</h1>
            <p class="subtitle">
                Observez des intelligences artificielles s'affronter dans un tournoi de Pong. Les raquettes apprennent et développent des styles de jeu uniques : défensif, agressif ou imprévisible. Suivez le bracket et découvrez quelles stratégies dominent !
            </p>
        </header>
        
        <div class="main-content">
            <div class="game-section">
                <h2 class="section-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="6" width="20" height="12" rx="2"></rect>
                        <path d="M6 12h4m6 0h2"></path>
                    </svg>
                    MATCH EN COURS
                </h2>
                <div class="game-container">
                    <canvas id="pongCanvas" width="700" height="400"></canvas>
                </div>
                
                <div class="controls">
                    <button id="startBtn">Démarrer le tournoi</button>
                    <button id="pauseBtn">Pause</button>
                    <button id="nextMatchBtn">Match suivant</button>
                    <button id="resetBtn">Nouveau tournoi</button>
                    <button id="unblockBtn">Débloquer match</button>
                </div>
                
                <div class="speed-controls">
                    <label for="speedSlider">Vitesse de simulation:</label>
                    <input type="range" id="speedSlider" class="speed-slider" min="0.1" max="5" step="0.1" value="1">
                    <span class="speed-display" id="speedDisplay">1.0x</span>
                </div>
                
                <div class="match-status" id="matchStatus">
                    <div>Statut: En attente</div>
                    <div id="matchTimer">Temps: 0s</div>
                    <div class="anti-block-info" id="antiBlockInfo">
                        Système anti-blocage: Actif
                    </div>
                </div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">GÉNÉRATION</div>
                        <div class="stat-value" id="generation">1</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">MATCH</div>
                        <div class="stat-value" id="matchCount">1/7</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">TOURNOI</div>
                        <div class="stat-value" id="tournament">1</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">VICTOIRES</div>
                        <div class="stat-value" id="wins">0</div>
                    </div>
                </div>
            </div>
            
            <div class="tournament-section">
                <h2 class="section-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15.5 22v-4a2 2 0 0 0-2-2h-3a2 2 0 0 0-2 2v4"></path>
                        <path d="M15.5 22h5.5a2 2 0 0 0 2-2v-9a2 2 0 0 0-2-2h-2"></path>
                        <path d="M3 4.5h8.5a2 2 0 0 1 2 2V12"></path>
                        <path d="M3 12h10"></path>
                        <path d="M3 4.5v17"></path>
                        <path d="M8 8h1"></path>
                        <path d="M8 12h1"></path>
                    </svg>
                    BRACKET DU TOURNOI
                </h2>
                <div class="bracket-container">
                    <div class="bracket" id="tournamentBracket">
                        <!-- Bracket will be generated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="analytics">
            <h2 class="section-title">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 21H6.2a2.8 2.8 0 0 1-2.8-2.8V3"></path>
                    <path d="m16 6-4 4-4-4-4 4"></path>
                    <path d="M3 10v11a2 2 0 0 0 2 2h14"></path>
                    <path d="M14 18h7"></path>
                    <path d="M14 14h7"></path>
                    <path d="M14 10h7"></path>
                </svg>
                ANALYSE DES STRATÉGIES
            </h2>
            <p>Les IA développent différents styles de jeu au fil des générations. Voici les stratégies émergentes :</p>
            
            <div class="styles-container">
                <div class="style-card aggressive-style">
                    <h3>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ff5252" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <path d="M10 15a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1"></path>
                            <path d="m8 12 2-2 2 2"></path>
                        </svg>
                        Style Agressif
                    </h3>
                    <ul>
                        <li>Attaque constante</li>
                        <li>Position haute sur le terrain</li>
                        <li>Vitesse de réaction maximale</li>
                        <li>Prise de risques élevée</li>
                        <li>Défense en mouvement</li>
                    </ul>
                    <div class="win-rate">Victoires: <span id="aggressiveWins">42%</span></div>
                </div>
                
                <div class="style-card defensive-style">
                    <h3>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4fc3f7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <circle cx="8" cy="16" r="2"></circle>
                            <path d="M9.5 12.5 12 10l5 5"></path>
                            <path d="M8 12h.01"></path>
                        </svg>
                        Style Défensif
                    </h3>
                    <ul>
                        <li>Position centrale par défaut</li>
                        <li>Anticipation des trajectoires</li>
                        <li>Défense de zone</li>
                        <li>Faible prise de risques</li>
                        <li>Contre-attaque efficace</li>
                    </ul>
                    <div class="win-rate">Victoires: <span id="defensiveWins">35%</span></div>
                </div>
                
                <div class="style-card unpredictable-style">
                    <h3>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ba68c8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <path d="M8 12h.01"></path>
                            <path d="M12 12h.01"></path>
                            <path d="M16 12h.01"></path>
                            <path d="M8 16h.01"></path>
                            <path d="M12 16h.01"></path>
                            <path d="M16 16h.01"></path>
                        </svg>
                        Style Imprévisible
                    </h3>
                    <ul>
                        <li>Mouvements aléatoires</li>
                        <li>Adaptation constante</li>
                        <li>Stratégies non conventionnelles</li>
                        <li>Difficile à anticiper</li>
                        <li>Réactions inattendues</li>
                    </ul>
                    <div class="win-rate">Victoires: <span id="unpredictableWins">23%</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables du jeu - DÉCLARATION EN PREMIER
        let ball;
        let leftPaddle;
        let rightPaddle;
        
        // Éléments DOM
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const nextMatchBtn = document.getElementById('nextMatchBtn');
        const resetBtn = document.getElementById('resetBtn');
        const unblockBtn = document.getElementById('unblockBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const matchStatus = document.getElementById('matchStatus');
        const matchTimer = document.getElementById('matchTimer');
        const antiBlockInfo = document.getElementById('antiBlockInfo');
        const bracketContainer = document.getElementById('tournamentBracket');
        
        // Paramètres du jeu
        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT = 100;
        const BALL_SIZE = 15;
        const PADDLE_SPEED = 8;
        const INITIAL_BALL_SPEED = 6;
        const MAX_BALL_SPEED = 12;
        
        // Paramètres anti-blocage
        const MATCH_TIMEOUT = 30000; // 30 secondes pour détecter un match bloqué
        const BALL_STUCK_THRESHOLD = 180; // 3 secondes à 60 FPS
        const NO_SCORE_TIMEOUT = 20000; // 20 secondes sans score
        
        // État du jeu
        let gameRunning = false;
        let tournamentStarted = false;
        let currentMatch = 0;
        let tournamentRound = 0;
        let generation = 1;
        let tournamentCount = 1;
        let wins = 0;
        let players = [];
        let tournamentMatches = [];
        let activeMatch = null;
        let gameSpeed = 1.0;
        
        // Variables anti-blocage
        let matchStartTime = 0;
        let lastScoreTime = 0;
        let isMatchBlocked = false;
        let ballStuckCounter = 0;
        let lastBallPosition = { x: 0, y: 0 };
        let blockDetectionCount = 0;
        
        // Gestion de la vitesse de simulation
        speedSlider.addEventListener('input', (e) => {
            gameSpeed = parseFloat(e.target.value);
            speedDisplay.textContent = gameSpeed.toFixed(1) + 'x';
        });
        
        // Création des joueurs IA
        function createPlayers() {
            players = [];
            for (let i = 0; i < 8; i++) {
                const style = i < 3 ? 'aggressive' : i < 6 ? 'defensive' : 'unpredictable';
                players.push({
                    id: i + 1,
                    name: `IA-${style.charAt(0).toUpperCase()}${i + 1}`,
                    style: style,
                    wins: 0,
                    losses: 0,
                    position: canvas.height / 2 - PADDLE_HEIGHT / 2,
                    ai: true,
                    reactionTime: style === 'aggressive' ? 0.9 : 
                                 style === 'defensive' ? 0.95 : 0.8,
                    aggression: style === 'aggressive' ? 0.8 : 
                                style === 'defensive' ? 0.2 : 0.5,
                    unpredictability: style === 'unpredictable' ? 0.7 : 0.1
                });
            }
        }
        
        // Initialiser le tournoi
        function initTournament() {
            tournamentMatches = [];
            tournamentRound = 0;
            currentMatch = 0;
            
            const shuffledPlayers = [...players].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < shuffledPlayers.length; i += 2) {
                tournamentMatches.push({
                    round: 0,
                    player1: shuffledPlayers[i],
                    player2: shuffledPlayers[i + 1],
                    winner: null,
                    score1: 0,
                    score2: 0,
                    active: false,
                    blocked: false
                });
            }
            
            renderBracket();
            updateMatchCount();
        }
        
        // Mettre à jour le compteur de matchs
        function updateMatchCount() {
            const totalMatches = 7; // 4 + 2 + 1 = 7 matchs au total
            const completedMatches = tournamentMatches.filter(m => m.winner).length;
            document.getElementById('matchCount').textContent = `${completedMatches + 1}/${totalMatches}`;
        }
        
        // Afficher le bracket du tournoi
        function renderBracket() {
            if (!bracketContainer) return;
            
            bracketContainer.innerHTML = '';
            
            for (let round = 0; round < 3; round++) {
                const roundEl = document.createElement('div');
                roundEl.className = 'round';
                roundEl.innerHTML = `<h3>Tour ${round + 1}</h3>`;
                
                const roundMatches = tournamentMatches.filter(match => match.round === round);
                
                roundMatches.forEach((match, index) => {
                    if (!match || !match.player1 || !match.player2) {
                        console.warn('Match ou joueur manquant:', match);
                        return;
                    }
                    
                    const matchEl = document.createElement('div');
                    let matchClass = 'match';
                    if (match.active) matchClass += ' active';
                    if (match.winner) matchClass += ' winner';
                    if (match.blocked) matchClass += ' blocked';
                    matchEl.className = matchClass;
                    
                    let player1Class = '';
                    let player2Class = '';
                    
                    if (match.winner) {
                        player1Class = match.winner.id === match.player1.id ? 'winner' : '';
                        player2Class = match.winner.id === match.player2.id ? 'winner' : '';
                    }
                    
                    matchEl.innerHTML = `
                        <div class="player ${player1Class} ${match.player1.style}">
                            <span></span>${match.player1.name}
                        </div>
                        <div>VS</div>
                        <div class="player ${player2Class} ${match.player2.style}">
                            <span></span>${match.player2.name}
                        </div>
                        <div class="score">${match.score1} - ${match.score2}</div>
                        ${match.blocked ? '<div style="color: #ff5252; font-size: 0.8rem;">BLOQUÉ</div>' : ''}
                    `;
                    
                    roundEl.appendChild(matchEl);
                });
                
                bracketContainer.appendChild(roundEl);
            }
        }
        
        // Détecter si un match est bloqué
        function checkMatchBlocked() {
            if (!activeMatch || !gameRunning) return;
            
            const currentTime = Date.now();
            const matchDuration = currentTime - matchStartTime;
            const timeSinceLastScore = currentTime - lastScoreTime;
            
            // Vérifier si la balle est coincée
            const ballDistance = Math.sqrt(
                Math.pow(ball.x - lastBallPosition.x, 2) + 
                Math.pow(ball.y - lastBallPosition.y, 2)
            );
            
            if (ballDistance < 1) {
                ballStuckCounter++;
            } else {
                ballStuckCounter = 0;
                lastBallPosition = { x: ball.x, y: ball.y };
            }
            
            // Conditions de blocage
            const isBallStuck = ballStuckCounter > BALL_STUCK_THRESHOLD;
            const isTimeout = timeSinceLastScore > NO_SCORE_TIMEOUT && matchDuration > MATCH_TIMEOUT;
            
            if ((isBallStuck || isTimeout) && !isMatchBlocked) {
                blockDetectionCount++;
                isMatchBlocked = true;
                activeMatch.blocked = true;
                
                matchStatus.classList.add('blocked');
                matchStatus.innerHTML = `
                    <div>Statut: MATCH BLOQUÉ</div>
                    <div>Raison: ${isBallStuck ? 'Balle coincée' : 'Timeout'}</div>
                    <div>Déblocage automatique en cours...</div>
                `;
                
                antiBlockInfo.innerHTML = `
                    Détection #${blockDetectionCount} - ${isBallStuck ? 'Balle immobile' : 'Pas de score'}
                `;
                
                renderBracket();
                
                // Déblocage automatique après 2 secondes
                setTimeout(() => {
                    unblockMatch();
                }, 2000);
            }
        }
        
        // Débloquer un match
        function unblockMatch() {
            if (!activeMatch) return;
            
            // Réinitialiser la balle avec une nouvelle position et vitesse aléatoire
            ball.x = canvas.width / 2 + (Math.random() - 0.5) * 100;
            ball.y = canvas.height / 2 + (Math.random() - 0.5) * 100;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * (INITIAL_BALL_SPEED + Math.random() * 2);
            ball.dy = (Math.random() * 2 - 1) * (INITIAL_BALL_SPEED + Math.random() * 2);
            
            // Réinitialiser les compteurs
            isMatchBlocked = false;
            ballStuckCounter = 0;
            lastScoreTime = Date.now();
            activeMatch.blocked = false;
            
            matchStatus.classList.remove('blocked');
            matchStatus.innerHTML = `
                <div>Statut: En cours (Débloqué)</div>
                <div id="matchTimer">Temps: ${Math.floor((Date.now() - matchStartTime) / 1000)}s</div>
            `;
            
            antiBlockInfo.innerHTML = `
                Système anti-blocage: Match débloqué avec succès
            `;
            
            renderBracket();
        }
        
        // Jouer un match
        function playMatch(matchIndex) {
            if (matchIndex < 0 || matchIndex >= tournamentMatches.length) {
                console.error('Index de match invalide:', matchIndex);
                return;
            }
            
            const match = tournamentMatches[matchIndex];
            if (!match) {
                console.error('Match introuvable à l\'index:', matchIndex);
                return;
            }
            
            match.active = true;
            match.blocked = false;
            activeMatch = match;
            currentMatch = matchIndex;
            matchStartTime = Date.now();
            lastScoreTime = Date.now();
            isMatchBlocked = false;
            ballStuckCounter = 0;
            blockDetectionCount = 0;
            
            matchStatus.classList.remove('blocked');
            matchStatus.innerHTML = `
                <div>Statut: En cours</div>
                <div id="matchTimer">Temps: 0s</div>
            `;
            
            antiBlockInfo.innerHTML = `
                Système anti-blocage: Surveillance active
            `;
            
            renderBracket();
            resetGame();
            gameRunning = true;
            gameLoop();
        }
        
        // Réinitialiser le jeu pour un nouveau match
        function resetGame() {
            ball = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: BALL_SIZE,
                dx: (Math.random() > 0.5 ? 1 : -1) * INITIAL_BALL_SPEED,
                dy: (Math.random() * 2 - 1) * INITIAL_BALL_SPEED,
                speed: INITIAL_BALL_SPEED
            };
            
            lastBallPosition = { x: ball.x, y: ball.y };
            
            if (activeMatch && activeMatch.player1 && activeMatch.player2) {
                leftPaddle = {
                    x: 20,
                    y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                    width: PADDLE_WIDTH,
                    height: PADDLE_HEIGHT,
                    dy: 0,
                    score: 0,
                    player: activeMatch.player1
                };
                
                rightPaddle = {
                    x: canvas.width - 20 - PADDLE_WIDTH,
                    y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                    width: PADDLE_WIDTH,
                    height: PADDLE_HEIGHT,
                    dy: 0,
                    score: 0,
                    player: activeMatch.player2
                };
            }
        }
        
        // Boucle principale du jeu avec vitesse variable
        function gameLoop() {
            if (!gameRunning) return;
            
            // Appliquer la vitesse de simulation
            for (let i = 0; i < Math.floor(gameSpeed); i++) {
                update();
                checkMatchBlocked();
            }
            
            // Gérer les vitesses fractionnaires
            if (Math.random() < (gameSpeed % 1)) {
                update();
                checkMatchBlocked();
            }
            
            draw();
            updateMatchTimer();
            
            // Vérifier si le match est terminé
            if (leftPaddle && rightPaddle && (leftPaddle.score >= 5 || rightPaddle.score >= 5)) {
                endMatch();
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Mettre à jour le timer du match
        function updateMatchTimer() {
            if (matchStartTime && gameRunning) {
                const elapsed = Math.floor((Date.now() - matchStartTime) / 1000);
                const timerElement = document.getElementById('matchTimer');
                if (timerElement) {
                    timerElement.textContent = `Temps: ${elapsed}s`;
                }
            }
        }
        
        // Mettre à jour l'état du jeu
        function update() {
            if (!ball || !leftPaddle || !rightPaddle) return;
            
            // Mettre à jour la position de la balle
            ball.x += ball.dx;
            ball.y += ball.dy;
            
            // Rebond en haut et en bas
            if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
                ball.dy = -ball.dy;
            }
            
            // Rebond sur les raquettes
            if (
                ball.x - ball.radius < leftPaddle.x + leftPaddle.width &&
                ball.y > leftPaddle.y &&
                ball.y < leftPaddle.y + leftPaddle.height &&
                ball.dx < 0
            ) {
                const hitPosition = (ball.y - (leftPaddle.y + leftPaddle.height / 2)) / (leftPaddle.height / 2);
                ball.dx = Math.abs(ball.dx) + 0.2;
                ball.dx = Math.min(ball.dx, MAX_BALL_SPEED);
                ball.dy = hitPosition * 5;
                ball.x = leftPaddle.x + leftPaddle.width + ball.radius;
            }
            
            if (
                ball.x + ball.radius > rightPaddle.x &&
                ball.y > rightPaddle.y &&
                ball.y < rightPaddle.y + rightPaddle.height &&
                ball.dx > 0
            ) {
                const hitPosition = (ball.y - (rightPaddle.y + rightPaddle.height / 2)) / (rightPaddle.height / 2);
                ball.dx = -Math.abs(ball.dx) - 0.2;
                ball.dx = Math.max(ball.dx, -MAX_BALL_SPEED);
                ball.dy = hitPosition * 5;
                ball.x = rightPaddle.x - ball.radius;
            }
            
            // Vérifier les points
            if (ball.x < 0) {
                rightPaddle.score++;
                lastScoreTime = Date.now();
                resetBall();
            } else if (ball.x > canvas.width) {
                leftPaddle.score++;
                lastScoreTime = Date.now();
                resetBall();
            }
            
            // IA pour les raquettes
            if (leftPaddle.player && leftPaddle.player.ai) {
                aiMove(leftPaddle, ball);
            }
            
            if (rightPaddle.player && rightPaddle.player.ai) {
                aiMove(rightPaddle, ball);
            }
            
            // Mettre à jour la position des raquettes
            leftPaddle.y += leftPaddle.dy;
            rightPaddle.y += rightPaddle.dy;
            
            // Empêcher les raquettes de sortir du terrain
            if (leftPaddle.y < 0) leftPaddle.y = 0;
            if (leftPaddle.y + leftPaddle.height > canvas.height) leftPaddle.y = canvas.height - leftPaddle.height;
            if (rightPaddle.y < 0) rightPaddle.y = 0;
            if (rightPaddle.y + rightPaddle.height > canvas.height) rightPaddle.y = canvas.height - rightPaddle.height;
        }
        
        // Logique de l'IA pour déplacer la raquette
        function aiMove(paddle, ball) {
            if (!paddle || !paddle.player || !ball) return;
            
            const player = paddle.player;
            const targetY = ball.y - paddle.height / 2;
            
            if (player.style === 'aggressive') {
                paddle.dy = (targetY - paddle.y) * player.reactionTime * 0.1;
                if (Math.random() < player.aggression) {
                    paddle.dy -= 1;
                }
            } else if (player.style === 'defensive') {
                paddle.dy = (targetY - paddle.y) * player.reactionTime * 0.05;
                const center = canvas.height / 2 - paddle.height / 2;
                paddle.dy += (center - paddle.y) * 0.02;
            } else {
                paddle.dy = (targetY - paddle.y) * player.reactionTime * 0.07;
                if (Math.random() < player.unpredictability) {
                    paddle.dy += (Math.random() * 4 - 2);
                }
            }
            
            paddle.dy = Math.max(-PADDLE_SPEED, Math.min(PADDLE_SPEED, paddle.dy));
        }
        
        // Réinitialiser la balle après un point
        function resetBall() {
            if (!ball) return;
            
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * INITIAL_BALL_SPEED;
            ball.dy = (Math.random() * 2 - 1) * INITIAL_BALL_SPEED;
            ball.speed = INITIAL_BALL_SPEED;
            ballStuckCounter = 0;
            lastBallPosition = { x: ball.x, y: ball.y };
        }
        
        // Dessiner le jeu
        function draw() {
            if (!ctx || !ball) return;
            
            ctx.fillStyle = '#0a1029';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            if (leftPaddle) drawPaddle(leftPaddle);
            if (rightPaddle) drawPaddle(rightPaddle);
            
            if (leftPaddle && rightPaddle) {
                ctx.font = '48px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'center';
                ctx.fillText(leftPaddle.score, canvas.width / 4, 60);
                ctx.fillText(rightPaddle.score, 3 * canvas.width / 4, 60);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = getStyleColor(leftPaddle.player.style);
                ctx.textAlign = 'left';
                ctx.fillText(leftPaddle.player.name, 20, 30);
                
                ctx.fillStyle = getStyleColor(rightPaddle.player.style);
                ctx.textAlign = 'right';
                ctx.fillText(rightPaddle.player.name, canvas.width - 20, 30);
            }
            
            // Indicateur de vitesse
            ctx.font = '14px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.textAlign = 'center';
            ctx.fillText(`Vitesse: ${gameSpeed.toFixed(1)}x`, canvas.width / 2, canvas.height - 20);
            
            // Indicateur anti-blocage si actif
            if (isMatchBlocked) {
                ctx.fillStyle = 'rgba(255, 82, 82, 0.8)';
                ctx.fillText('MATCH BLOQUÉ - DÉBLOCAGE EN COURS', canvas.width / 2, 50);
            }
        }
        
        function drawPaddle(paddle) {
            if (!paddle || !paddle.player || !ctx) return;
            
            ctx.fillStyle = getStyleColor(paddle.player.style);
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(paddle.x, paddle.y, 5, paddle.height);
        }
        
        function getStyleColor(style) {
            switch(style) {
                case 'aggressive': return '#ff5252';
                case 'defensive': return '#4fc3f7';
                case 'unpredictable': return '#ba68c8';
                default: return '#ffffff';
            }
        }
        
        // Terminer un match
        function endMatch() {
            gameRunning = false;
            
            if (!activeMatch || !leftPaddle || !rightPaddle) return;
            
            let winner;
            if (leftPaddle.score > rightPaddle.score) {
                winner = leftPaddle.player;
                wins++;
            } else {
                winner = rightPaddle.player;
                wins++;
            }
            
            activeMatch.winner = winner;
            activeMatch.score1 = leftPaddle.score;
            activeMatch.score2 = rightPaddle.score;
            activeMatch.active = false;
            activeMatch.blocked = false;
            
            winner.wins++;
            if (winner === leftPaddle.player) {
                rightPaddle.player.losses++;
            } else {
                leftPaddle.player.losses++;
            }
            
            document.getElementById('wins').textContent = wins;
            updateWinRates();
            updateMatchCount();
            
            matchStatus.classList.remove('blocked');
            matchStatus.innerHTML = `
                <div>Statut: Match terminé</div>
                <div>Gagnant: ${winner.name}</div>
            `;
            
            antiBlockInfo.innerHTML = `
                Système anti-blocage: Match terminé normalement
            `;
            
            renderBracket();
            
            setTimeout(() => {
                nextMatch();
            }, 2000);
        }
        
        // Mettre à jour les taux de victoire
        function updateWinRates() {
            const aggressiveWins = players.filter(p => p.style === 'aggressive').reduce((sum, p) => sum + p.wins, 0);
            const defensiveWins = players.filter(p => p.style === 'defensive').reduce((sum, p) => sum + p.wins, 0);
            const unpredictableWins = players.filter(p => p.style === 'unpredictable').reduce((sum, p) => sum + p.wins, 0);
            
            const aggressiveElement = document.getElementById('aggressiveWins');
            const defensiveElement = document.getElementById('defensiveWins');
            const unpredictableElement = document.getElementById('unpredictableWins');
            
            if (aggressiveElement) aggressiveElement.textContent = aggressiveWins;
            if (defensiveElement) defensiveElement.textContent = defensiveWins;
            if (unpredictableElement) unpredictableElement.textContent = unpredictableWins;
        }
        
        // Passer au match suivant
        function nextMatch() {
            currentMatch++;
            
            if (currentMatch >= tournamentMatches.filter(m => m.round === tournamentRound).length) {
                tournamentRound++;
                
                if (tournamentRound >= 3) {
                    endTournament();
                    return;
                }
                
                const winners = tournamentMatches
                    .filter(m => m.round === tournamentRound - 1 && m.winner)
                    .map(m => m.winner);
                
                for (let i = 0; i < winners.length; i += 2) {
                    if (winners[i] && winners[i + 1]) {
                        tournamentMatches.push({
                            round: tournamentRound,
                            player1: winners[i],
                            player2: winners[i + 1],
                            winner: null,
                            score1: 0,
                            score2: 0,
                            active: false,
                            blocked: false
                        });
                    }
                }
                
                currentMatch = 0;
            }
            
            const nextMatchIndex = tournamentMatches.findIndex(m => m.round === tournamentRound && !m.winner);
            if (nextMatchIndex !== -1) {
                playMatch(nextMatchIndex);
            }
        }
        
        // Terminer le tournoi
        function endTournament() {
            tournamentStarted = false;
            const finalMatch = tournamentMatches.find(m => m.round === 2);
            if (finalMatch && finalMatch.winner) {
                alert(`Tournoi terminé ! Le champion est ${finalMatch.winner.name} (${finalMatch.winner.style})`);
            }
            
            evolvePlayers();
            generation++;
            document.getElementById('generation').textContent = generation;
        }
        
        // Évoluer les joueurs pour la prochaine génération
        function evolvePlayers() {
            const topPlayers = [...players]
                .sort((a, b) => b.wins - a.wins)
                .slice(0, 4);
            
            const newPlayers = [...topPlayers];
            
            for (let i = 0; i < 4; i++) {
                const parent1 = topPlayers[i % topPlayers.length];
                const parent2 = topPlayers[(i + 1) % topPlayers.length];
                
                const newStyle = Math.random() < 0.5 ? parent1.style : parent2.style;
                
                const newPlayer = {
                    id: newPlayers.length + 1,
                    name: `IA-${newStyle.charAt(0).toUpperCase()}${newPlayers.length + 1}`,
                    style: newStyle,
                    wins: 0,
                    losses: 0,
                    position: canvas.height / 2 - PADDLE_HEIGHT / 2,
                    ai: true,
                    reactionTime: (parent1.reactionTime + parent2.reactionTime) / 2 + (Math.random() - 0.5) * 0.1,
                    aggression: (parent1.aggression + parent2.aggression) / 2 + (Math.random() - 0.5) * 0.1,
                    unpredictability: (parent1.unpredictability + parent2.unpredictability) / 2 + (Math.random() - 0.5) * 0.1
                };
                
                if (Math.random() < 0.3) {
                    newPlayer.reactionTime += (Math.random() - 0.5) * 0.2;
                    newPlayer.reactionTime = Math.max(0.5, Math.min(1, newPlayer.reactionTime));
                }
                
                if (Math.random() < 0.3) {
                    newPlayer.aggression += (Math.random() - 0.5) * 0.3;
                    newPlayer.aggression = Math.max(0, Math.min(1, newPlayer.aggression));
                }
                
                if (Math.random() < 0.3) {
                    newPlayer.unpredictability += (Math.random() - 0.5) * 0.3;
                    newPlayer.unpredictability = Math.max(0, Math.min(1, newPlayer.unpredictability));
                }
                
                newPlayers.push(newPlayer);
            }
            
            players = newPlayers;
        }
        
        // Initialiser l'application
        function init() {
            createPlayers();
            initTournament();
            
            startBtn.addEventListener('click', () => {
                if (!tournamentStarted) {
                    tournamentStarted = true;
                    playMatch(0);
                }
            });
            
            pauseBtn.addEventListener('click', () => {
                gameRunning = !gameRunning;
                if (gameRunning) gameLoop();
                pauseBtn.textContent = gameRunning ? 'Pause' : 'Reprendre';
            });
            
            nextMatchBtn.addEventListener('click', nextMatch);
            
            unblockBtn.addEventListener('click', unblockMatch);
            
            resetBtn.addEventListener('click', () => {
                gameRunning = false;
                tournamentStarted = false;
                tournamentCount++;
                document.getElementById('tournament').textContent = tournamentCount;
                wins = 0;
                document.getElementById('wins').textContent = wins;
                createPlayers();
                initTournament();
                
                matchStatus.classList.remove('blocked');
                matchStatus.innerHTML = `
                    <div>Statut: En attente</div>
                    <div>Temps: 0s</div>
                `;
                
                antiBlockInfo.innerHTML = `
                    Système anti-blocage: Actif
                `;
            });
            
            resetGame();
            draw();
        }
        
        init();
    </script>
</body>
</html>
